<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="x6.min.js"></script>
    <title>家系图</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        #box {
            height: 100vh;
            width: 100vw;
        }

        .wrap {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            background-color: #fff;
            /*padding: 20px;*/
            font-size: 14px;
        }

        .node-header {
            position: absolute;
            top: 0;
            color: #fff;
            text-align: center;
            width: 100%;
            height: 20px;
            font-size: 12px;
        }

        .male {
            border: 2px solid #9254de;
        }

        .female {
            border: 2px solid #BC53AB;
        }

        .html-point {
            background-image: url("./love.png");
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
        }
    </style>
</head>
<body>
<div id="box">
    <div style="width: 100%; height: 100%;">
        <div id="container"></div>
    </div>
</div>

<script type="module">
    import DATA from './genogram.js'

    const {Graph, Shape} = window.X6
    const gapX = 80
    const gapY = 100
    const nodeWidth = 200
    const nodeHeight = 100
    const loveSize = 24

    // 注册边
    Graph.registerEdge('x6-edge', {
        zIndex: -1,
        attrs: {
            line: {
                fill: 'none',
                strokeLinejoin: 'round',
                strokeWidth: 1,
                stroke: '#5F95FF',
                sourceMarker: null,
                targetMarker: null,
            },
        },
    }, true)
    // 注册节点
    Shape.HTML.register({
        shape: 'html-node',
        width: 200,
        height: 100,
        html: (cell) => {
            const data = cell.getData()
            const wrap = document.createElement('div')
            wrap.className = 'wrap'
            wrap.innerHTML = `
            <div>${data['姓名']}</div>
            <div>${data['详情']}</div>
            `

            const header = document.createElement('div')
            header.className = 'node-header'
            header.innerText = data['关系']
            wrap.appendChild(header)
            if (data.gender === 'male') {
                wrap.classList.add('male')
                header.style.backgroundColor = '#9254de'
            } else {
                wrap.classList.add('female')
                header.style.backgroundColor = '#BC53AB'
            }
            return wrap
        },
    })
    Shape.HTML.register({
        shape: 'html-point',
        width: 200,
        height: 100,
        html: (cell) => {
            const data = cell.getData()
            const wrap = document.createElement('div')
            wrap.className = 'html-point'
            wrap.style.width = `${loveSize}px`
            wrap.style.height = `${loveSize}px`
            return wrap
        },
    })
    // 生成画布
    const boxDom = document.getElementById('box')
    const graph = new Graph({
        container: document.getElementById('container'),
        width: boxDom.clientWidth,
        height: boxDom.clientHeight,
        background: {
            color: "#F2F7FA",
        },
        panning: true,
        mousewheel: true,
        grid: true,
        autoResize: true,
        interacting: {
            nodeMovable: true,
            edgeMovable: true,
        },
    })

    /**
     * 生成节点
     * @param x
     * @param y
     * @param people
     * @param config
     * @returns {*}
     */
    function generateNode(x, y, people, config = {}) {
        return graph.addNode({
            x,
            y,
            // shape: 'x6-node',
            shape: 'html-node',
            attrs: {
                name: {
                    text: `${people['姓名'] || ''}`
                },
                ...config.attrs
            },
            data: people
        })
    }

    /**
     * 连线节点
     * @param source
     * @param target
     * @param vertices
     * @param config
     * @returns {*}
     */
    function link(source, target, vertices, config) {
        return graph.addEdge({
            shape: 'x6-edge',
            // connector: {
            //     name: 'rounded',
            //     args: {radius: 10},
            // },
            source: {
                cell: source,
            },
            target: {
                cell: target,
            },

            vertices,
            ...(config ? config : {
                attrs: {
                    line: {
                        // targetMarker: 'classic',
                    },
                }
            })

        })
    }

    // 定值
    const mine = DATA.find(item => item['关系'] === '本人')
    const mineNode = generateNode(0, 0, mine)

    const nodeGapX = nodeWidth + gapX
    const nodeGapY = nodeHeight + gapY

    /**
     *
     * @param baseNode
     * @param isSinger 单节点
     * @param {"T"|"B"} direction
     * @returns {[{x: *, y},{x: *, y: number}]}
     */
    function getLink(baseNode, isSinger = false, direction = 'T') {
        if (!isSinger) {
            if (direction === 'T') {
                return [
                    {
                        x: baseNode.position().x + nodeWidth + gapX / 2,
                        y: baseNode.position().y - gapY / 2,
                    },
                    {
                        x: baseNode.position().x + nodeWidth + gapX / 2,
                        y: baseNode.position().y + nodeHeight / 2,
                    }
                ]
            } else {
                return [
                    {
                        x: baseNode.position().x + nodeWidth + gapX / 2,
                        y: baseNode.position().y + nodeHeight + gapY / 2,
                    },
                    {
                        x: baseNode.position().x + nodeWidth + gapX / 2,
                        y: baseNode.position().y + nodeHeight / 2,
                    }
                ]
            }
        } else {
            if (direction === 'T') {
                return [
                    {
                        x: baseNode.position().x + nodeWidth / 2,
                        y: baseNode.position().y,
                    },
                    {
                        x: baseNode.position().x + nodeWidth / 2,
                        y: baseNode.position().y - gapY / 2,
                    }
                ]
            } else {
                return [
                    {
                        x: baseNode.position().x + nodeWidth / 2,
                        y: baseNode.position().y + (nodeHeight + gapY / 2),
                    },
                    {
                        x: baseNode.position().x + nodeWidth / 2,
                        y: baseNode.position().y + (nodeHeight + gapY / 2),
                    }
                ]
            }
        }
    }

    /**
     * 获取同辈节点之间的间距
     * @param data
     * @param max
     * @returns {number|number}
     */
    function getMaxLength(data, max = 0) {
        const sons = DATA.filter(item => item.fid === data.id || item.mid === data.id)
        let maxNum = max > sons.length ? max : sons.length
        if (sons.length > 0) {
            sons.forEach(son => {
                maxNum = max > getMaxLength(son, maxNum) ? max : getMaxLength(son, maxNum)
            })
        }
        return maxNum
    }

    function getMaxElderLength(data, max = 0) {
        const elders = DATA.filter(item => item.id === data.fid || item.id === data.mid)
        let maxNum = max > elders.length ? max : elders.length
        if (elders.length > 0) {
            elders.forEach(son => {
                maxNum = max > getMaxLength(son, maxNum) ? max : getMaxLength(son, maxNum)
            })
        }
        return maxNum
    }

    /**
     * 妻子节点
     * @param baseNode
     */
    function getCouples(baseNode) {
        const coordinate = {
            x: baseNode.position().x,
            y: baseNode.position().y
        } // 坐标
        const baseData = baseNode.data
        // baseData 的对象
        const couples = DATA.filter(item => (baseData?.pids || []).includes(item.id + ''))
        switch (couples.length) {
            case 0:
                break
            case 1:
                if (baseData.gender === 'male') {
                    const coupleNode = generateNode(coordinate.x + nodeGapX, coordinate.y, couples[0])
                    link(baseNode, coupleNode)
                    getElderNew(coupleNode)
                    getPeer(coupleNode)
                }
                if (baseData.gender === 'female') {
                    const coupleNode = generateNode(coordinate.x - nodeGapX, coordinate.y, couples[0])
                    link(baseNode, coupleNode)
                    getElderNew(coupleNode)
                    getPeer(coupleNode)
                }
                break
            case 2:
                couples.forEach((item, index) => {
                    // *3 给父母留出空间
                    coordinate.x = baseNode.position().x + (index === 0 ? nodeGapX : -nodeGapX)
                    const coupleNode = generateNode(coordinate.x, coordinate.y, item)
                    link(baseNode, coupleNode)
                })
                break
            default:
                // 超过两位夫妻
                break
        }
    }

    /**
     * 父母节点
     * @param baseNode
     */
    function getElder(baseNode) {
        const coordinate = {
            x: baseNode.position().x,
            y: baseNode.position().y
        } // 坐标
        const baseData = baseNode.data
        // 直系长辈
        const elder = DATA.filter(item => item.id === baseData.fid || item.id === baseData.mid)
        if (baseData.gender === 'male') {
            if (elder.length > 0) {
                const hasFather = elder.some(item => item.gender === 'male')
                const hasMother = elder.some(item => item.gender === 'female')
                /**
                 * 父母都有就只创建父亲节点，通过 getWife 获取母亲节点
                 */
                if (hasFather) {
                    const father = elder.find(item => item.gender === 'male')
                    // fatherNode
                    coordinate.x = baseNode.position().x + (hasMother ? -nodeGapX : 0)
                    coordinate.y = baseNode.position().y - nodeGapY
                    let elderMax = getMaxElderLength(father)
                    const gap = elderMax > 0 ? nodeGapX * (elderMax - 1) : 0
                    const fatherNode = generateNode(coordinate.x - gap, coordinate.y, father)
                    link(baseNode, fatherNode, [
                        ...getLink(baseNode, true),
                        ...getLink(fatherNode, !hasMother, 'B'),
                    ])
                    getElder(fatherNode)
                    getPeer(fatherNode)
                    if (hasMother) {
                        getCouples(fatherNode)
                    }
                } else {
                    if (hasMother) {
                        // motherNode
                        const mother = elder.find(item => item.gender === 'female')
                        coordinate.x = baseNode.position().x
                        coordinate.y = baseNode.position().y - nodeGapY
                        const motherNode = generateNode(coordinate.x, coordinate.y, mother)
                        link(baseNode, motherNode, [
                            ...getLink(baseNode, true),
                            ...getLink(motherNode, true, 'B'),
                        ])
                        getElder(motherNode)
                    }
                }
            }
        } else {
            if (elder.length > 0) {
                const hasFather = elder.some(item => item.gender === 'male')
                const hasMother = elder.some(item => item.gender === 'female')
                /**
                 * 父母都有就只创建父亲节点，通过 getWife 获取母亲节点
                 */
                if (hasFather) {
                    const father = elder.find(item => item.gender === 'male')
                    // fatherNode
                    coordinate.x = baseNode.position().x
                    coordinate.y = baseNode.position().y - nodeGapY
                    let max = getMaxElderLength(father)
                    const gap = max > 0 ? nodeGapX * (max - 1) : 0
                    const fatherNode = generateNode(coordinate.x + gap, coordinate.y, father)
                    link(baseNode, fatherNode, [
                        ...getLink(baseNode, true),
                        ...getLink(fatherNode, false, 'B'),
                    ])
                    getElder(fatherNode)
                    // getPeer(fatherNode)
                    if (hasMother) {
                        getCouples(fatherNode)
                    }
                } else {
                    if (hasMother) {
                        // motherNode
                        const mother = elder.find(item => item.gender === 'female')
                        coordinate.x = baseNode.position().x + nodeGapX
                        coordinate.y = baseNode.position().y - nodeGapY
                        const motherNode = generateNode(coordinate.x, coordinate.y, mother)
                        link(baseNode, motherNode, [
                            ...getLink(baseNode, true),
                            ...getLink(motherNode, true, 'B'),
                        ])
                        getElder(motherNode)
                    }
                }
            }
        }
    }

    /**
     * 同辈
     * @param baseNode
     */
    function getPeer(baseNode) {
        const coordinate = {
            x: baseNode.position().x,
            y: baseNode.position().y
        } // 坐标
        const baseData = baseNode.data
        let node = null
        // 同辈数组
        let peers = DATA.filter(item => baseData.fid && baseData.mid && item.id !== baseData.id && (item.fid === baseData.fid || item.mid === baseData.mid))
        if (baseData.gender === 'male') {
            peers.reduce((prev, cur) => {
                const prevNode = prev ? prev : baseNode
                coordinate.x = prevNode.position().x - nodeGapX
                coordinate.y = prevNode.position().y
                const maxLength = getMaxLength(cur)
                if (cur?.pids && cur.pids.length > 0) {
                    coordinate.x = coordinate.x - nodeGapX * (maxLength + 1)
                    node = generateNode(coordinate.x, coordinate.y, cur)
                } else {
                    node = generateNode(coordinate.x, coordinate.y, cur)
                }
                getCouples(node)
                return node
            }, null)
        } else {
            peers.reduce((prev, cur) => {
                const prevNode = prev ? prev : baseNode
                coordinate.x = prevNode.position().x + nodeGapX
                coordinate.y = prevNode.position().y
                const maxLength = getMaxLength(cur)
                if (cur?.pids && cur.pids.length > 0) {
                    coordinate.x = coordinate.x + nodeGapX * (maxLength + 1)
                    node = generateNode(coordinate.x, coordinate.y, cur)
                } else {
                    node = generateNode(coordinate.x, coordinate.y, cur)
                }
                link(baseNode, node, [
                    {
                        x: baseNode.position().x + nodeWidth / 2,
                        y: baseNode.position().y - gapY / 2
                    },
                    {
                        x: node.position().x + nodeWidth / 2,
                        y: node.position().y - gapY / 2
                    }
                ])
                getCouples(node)
                return node
            }, null)
        }
    }

    function getElderNew(baseNode) {
        const coordinate = {
            x: baseNode.position().x,
            y: baseNode.position().y
        } // 坐标
        const baseData = baseNode.data

        // 最长同辈长度
        function getPeerMaxLength(data, max = 0) {
            const elders = DATA.filter(item => item.id === data.fid || item.id === data.mid)
            let maxNum = max > elders.length ? max : elders.length
            if (elders.length > 0) {
                elders.forEach(elder => {
                    maxNum = max > getMaxLength(elder, maxNum) ? max : getMaxLength(elder, maxNum)
                })
            }
            return maxNum
        }

        const elders = DATA.filter(item => item.id === baseData.fid || item.id === baseData.mid)
        let max = 0
        elders.reduce((prev, cur) => {
            let num = getPeerMaxLength(cur)
            max = (prev > num ? prev : num) // 同辈中的最多的数量
            return prev > num ? prev : num
        }, 0)
        if (baseData.gender === 'male') {
            if (elders.length > 0) {
                const father = elders.find(item => item.gender === 'male')
                const mother = elders.find(item => item.gender === 'female')
                coordinate.x = baseNode.position().x - (nodeGapX * max + nodeGapX)
                coordinate.y = baseNode.position().y - nodeGapY
                const fatherNode = generateNode(coordinate.x, coordinate.y, father)
                link(baseNode, fatherNode, [
                    {
                        x: baseNode.position().x + nodeWidth / 2,
                        y: baseNode.position().y - gapY / 2
                    },
                    {
                        x: fatherNode.position().x + nodeWidth + gapX / 2,
                        y: fatherNode.position().y + gapY / 2 + nodeHeight
                    },
                    {
                        x: fatherNode.position().x + nodeWidth + gapX / 2,
                        y: fatherNode.position().y + gapY / 2
                    }
                ])
                getElderNew(fatherNode)
                getPeer(fatherNode)
                if (mother) {
                    getCouples(fatherNode)
                }
            }
        }
        if (baseData.gender === 'female') {
            if (elders.length > 0) {
                const father = elders.find(item => item.gender === 'male')
                const mother = elders.find(item => item.gender === 'female')
                coordinate.x = baseNode.position().x + (nodeGapX * max)
                coordinate.y = baseNode.position().y - nodeGapY
                const fatherNode = generateNode(coordinate.x, coordinate.y, father)
                link(baseNode, fatherNode, [
                    {
                        x: baseNode.position().x + nodeWidth / 2,
                        y: baseNode.position().y - gapY / 2
                    },
                    {
                        x: fatherNode.position().x + nodeWidth + gapX / 2,
                        y: fatherNode.position().y + gapY / 2 + nodeHeight
                    },
                    {
                        x: fatherNode.position().x + nodeWidth + gapX / 2,
                        y: fatherNode.position().y + gapY / 2
                    }
                ])
                getElderNew(fatherNode)
                getPeer(fatherNode)
                if (mother) {
                    getCouples(fatherNode)
                }
            }
        }
    }

    function init(benchmarkNode) {
        let peersNum = 0
        // 获取对象(目前只考虑两位妻子的情况)
        getCouples(benchmarkNode)
        // 获取父母 (以父亲为基准)
        getElderNew(benchmarkNode)
        // 获取子辈
        // getOffSpring(benchmarkNode)
        // 获取同辈
        getPeer(benchmarkNode)
    }

    init(mineNode)
    graph.zoomToFit({
        maxScale: 1,
        padding: 30
    })
    graph.centerContent(); // 将画布中元素居中展示
</script>
</body>
</html>