<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="x6.min.js"></script>
    <title>家系图</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        #box {
            height: 100vh;
            width: 100vw;
        }

        .wrap {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            background-color: #fff;
            /*padding: 20px;*/
            font-size: 14px;
        }

        .node-header {
            position: absolute;
            top: 0;
            color: #fff;
            text-align: center;
            width: 100%;
            height: 20px;
            font-size: 12px;
        }

        .male {
            border: 2px solid #9254de;
        }

        .female {
            border: 2px solid #BC53AB;
        }
    </style>
</head>
<body>
<div id="box">
    <div style="width: 100%; height: 100%;">
        <div id="container"></div>
    </div>
</div>

<script type="module">
    import DATA from './genogram.js'

    const {Graph, Shape} = window.X6
    // 注册边
    Graph.registerEdge('x6-edge', {
        zIndex: -1,
        attrs: {
            line: {
                fill: 'none',
                strokeLinejoin: 'round',
                strokeWidth: 1,
                stroke: '#5F95FF',
                sourceMarker: null,
                targetMarker: null,
            },
        },
    }, true)
    // 注册节点
    Shape.HTML.register({
        shape: 'html-node',
        width: 200,
        height: 100,
        html: (cell) => {
            const data = cell.getData()
            const wrap = document.createElement('div')
            wrap.className = 'wrap'
            wrap.innerHTML = `
            <div>${data['姓名']}</div>
            <div>${data['详情']}</div>
            `

            const header = document.createElement('div')
            header.className = 'node-header'
            header.innerText = data['关系']
            wrap.appendChild(header)
            if (data.gender === 'male') {
                wrap.classList.add('male')
                header.style.backgroundColor = '#9254de'
            } else {
                wrap.classList.add('female')
                header.style.backgroundColor = '#BC53AB'
            }
            return wrap
        },
    })
    Shape.HTML.register({
        shape: 'html-point',
        width: 200,
        height: 100,
        html: (cell) => {
            const data = cell.getData()
            const wrap = document.createElement('div')
            return wrap
        },
    })
    // 生成画布
    const boxDom = document.getElementById('box')
    const graph = new Graph({
        container: document.getElementById('container'),
        width: boxDom.clientWidth,
        height: boxDom.clientHeight,
        background: {
            color: "#F2F7FA",
        },
        panning: true,
        mousewheel: true,
        grid: true,
        autoResize: true,
    })

    /**
     * 生成节点
     * @param x
     * @param y
     * @param people
     * @param config
     * @returns {*}
     */
    function generateNode(x, y, people, config = {}) {
        return graph.addNode({
            x,
            y,
            // shape: 'x6-node',
            shape: 'html-node',
            attrs: {
                name: {
                    text: `${people['姓名'] || ''}`
                },
                ...config.attrs
            },
            data: people
        })
    }

    /**
     * 连线节点
     * @param source
     * @param target
     * @param vertices
     * @param config
     * @returns {*}
     */
    function link(source, target, vertices, config) {
        return graph.addEdge({
            shape: 'x6-edge',
            // connector: {
            //     name: 'rounded',
            //     args: {radius: 10},
            // },
            source: {
                cell: source,
            },
            target: {
                cell: target,
            },

            vertices,
            ...(config ? config : {
                attrs: {
                    line: {
                        targetMarker: 'classic',
                    },
                }
            })

        })
    }

    function getCouple(benchmarkNode) {
        const benchmark = benchmarkNode.data
        const couples = DATA.filter(item => benchmark.pids.includes(item.id + ''))
        if (couples.length > 0) {
            if (benchmark.gender === 'male') { // 男性
                couples.forEach((couple, index) => {
                    // 妻子一定在右边
                    const coordinate = {
                        x: benchmarkNode.position().x + (index % 2 === 0 ? (nodeWidth + gapX) : -(nodeWidth + gapX)),
                        y: benchmarkNode.position().y
                    }
                    const coupleNode = generateNode(coordinate.x, coordinate.y, couple)
                    link(benchmarkNode, coupleNode)
                    getElder(coupleNode)
                })
            } else { // 女性
                couples.forEach((couple, index) => {
                    // 丈夫一定在左边
                    const coordinate = {
                        x: benchmarkNode.position().x + (index % 2 === 0 ? (nodeWidth + gapX) : -(nodeWidth + gapX)),
                        y: benchmarkNode.position().y
                    }
                    const coupleNode = generateNode(coordinate.x, coordinate.y, couple)
                    link(benchmarkNode, coupleNode)
                    getElder(coupleNode)
                })
            }
        }
    }

    function getElder(benchmarkNode) {
        const benchmark = benchmarkNode.data
        function __get(benchmarkNode, nodeData) {
            const benchmark = benchmarkNode.data
            const coordinate = {
                x: benchmarkNode.position().x,
                y: benchmarkNode.position().y - (nodeHeight + gapY)
            }
            if(benchmark.gender === 'male' && nodeData.pids.length > 0) {
                coordinate.x = benchmarkNode.position().x - (nodeWidth + gapX)
            }
            const elderNode = generateNode(coordinate.x, coordinate.y, nodeData)
            link(benchmarkNode, elderNode, [
                {
                    x: benchmarkNode.position().x + nodeWidth + gapX /2,
                    y: benchmarkNode.position().y + nodeHeight / 2
                },
                {
                    x: benchmarkNode.position().x + nodeWidth + gapX /2,
                    y: benchmarkNode.position().y - gapY / 2
                },
                {
                    x: elderNode.position().x + nodeWidth + gapX / 2,
                    y: elderNode.position().y + nodeHeight + gapY / 2
                },
                {
                    x: elderNode.position().x + nodeWidth + gapX / 2,
                    y: elderNode.position().y + gapY / 2
                }
            ])
            getCouple(elderNode)
            getElder(elderNode)
        }
        const elders = DATA.filter(item => item.id === benchmark.fid || item.id === benchmark.mid)
        const father = elders.find(item => item.gender === 'male')
        const mother = elders.find(item => item.gender === 'female')
        if (father) {
            __get(benchmarkNode, father)
        } else {
            if (mother) {
                __get(benchmarkNode, mother)
            }
        }
    }


    const gapX = 80
    const gapY = 100
    const nodeWidth = 200
    const nodeHeight = 100
    // 定值
    const mine = DATA.find(item => item['姓名'] === '本人')
    const mineNode = generateNode(0, 0, mine)

    function init(benchmarkNode, direction = 'L') {
        const benchmark = benchmarkNode.data
        let elders = null // 长辈
        let peers = null // 同辈
        let offsprings = null // 子辈
        let couples = null // 夫妻

        // 获取妻子(目前只考虑两位妻子的情况)
        getCouple(mineNode)
        // 获取父母 (以父亲为基准)
        getElder(benchmarkNode)

    }

    init(mineNode)
    graph.zoomToFit({
        maxScale: 1,
        padding: 30
    })
    graph.centerContent(); // 将画布中元素居中展示
</script>
</body>
</html>